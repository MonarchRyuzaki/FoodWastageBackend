mport { createFoodWastageSparqlClient } from "./SparqlClient.js";
const client = createFoodWastageSparqlClient();

export async function searchDonations({
  ngoLat,
  ngoLong,
  maxDistanceKm = 10,

  status = ["Available"],
  priority = ["High", "Medium", "Low"],

  prefersFoodType = [],
  rejectsFoodType = [],
  avoidsAllergens = [],
}) {
  // 0. Normalize single‐value filters into arrays
  const statusList = Array.isArray(status) ? status : [status];
  const priorityList = Array.isArray(priority) ? priority : [priority];

  // 1. Base WHERE clauses
  const where = [
    "?donation        a :FoodDonation .",
    "?donation        :hasFoodType       ?foodType .",
    "?donation        :containsAllergen  ?allergen .",
    "?donation        :hasDonationStatus ?status .",
    "?donation        :hasPriority       ?priority .",
    "?donation        :hasDonationLocation ?loc .",
    "?loc             :hasLatitude       ?lat .",
    "?loc             :hasLongitude      ?long .",
  ];

  // 2. Exclude clauses
  const excludeClauses = [];
  if (rejectsFoodType.length) {
    excludeClauses.push(
      `FILTER NOT EXISTS {
         VALUES ?foodType { ${rejectsFoodType.map((t) => `:${t}`).join(" ")} }
       }`
    );
  }
  if (avoidsAllergens.length) {
    excludeClauses.push(
      `FILTER NOT EXISTS {
         VALUES ?allergen { ${avoidsAllergens.map((a) => `:${a}`).join(" ")} }
       }`
    );
  }

  // 3. Distance clauses
  const distanceClauses = [
    `BIND(
      geof:distance(
        STRDT(
          CONCAT("Point(", STR(?long), " ", STR(?lat), ")"),
          geo:wktLiteral
        ),
        STRDT("Point(${ngoLong} ${ngoLat})", geo:wktLiteral),
        uom:kilometer
      )
    AS ?distKm)`,
    `FILTER(?distKm <= ${maxDistanceKm})`,
  ];

  // 4. Filter clauses for status and priority
  const valueFilters = [];
  if (statusList.length) {
    valueFilters.push(
      `VALUES ?status { ${statusList.map((s) => `:${s}`).join(" ")} }`
    );
  }
  if (priorityList.length) {
    valueFilters.push(
      `VALUES ?priority { ${priorityList.map((p) => `:${p}`).join(" ")} }`
    );
  }

  // 5. Build ORDER BY
  let orderExpr;
  if (prefersFoodType.length) {
    // e.g. IF(?foodType = :Meat || ?foodType = :Fruit, 0, 1) ?distKm
    const prefConditions = prefersFoodType
      .map((t) => `?foodType = :${t}`)
      .join(" || ");
    orderExpr = `IF(${prefConditions}, 0, 1) ?distKm`;
  } else {
    orderExpr = "?distKm";
  }

  // 6. Final SPARQL query
  const sparql = `
    PREFIX geo-pos: <http://www.w3.org/2003/01/geo/wgs84_pos#>
    PREFIX geo-ont: <http://www.geonames.org/ontology#>
    PREFIX omgeo: <http://www.ontotext.com/owlim/geo#>

    SELECT
      ?donation ?foodType ?allergen ?status ?priority ?lat ?long ?distKm
    WHERE {
      ${where.join("\n      ")}
      ${excludeClauses.join("\n      ")}
      ${distanceClauses.join("\n      ")}
      ${valueFilters.join("\n      ")}
      }
      ORDER BY ${orderExpr}
      LIMIT 100
      `;
      console.log("SPARQL Query:", sparql);
  try {
    const { results } = await client.query(sparql);
    return results.bindings;
  } catch (err) {
    // console.error(
    //   "Error executing searchDonations query:",
    //   err.response?.data || err
    // );
    // throw err;c
  }
}

const results = await searchDonations({
  ngoLat: 12.9716,
  ngoLong: 77.5946,
  maxDistanceKm: 1500,
  status: "Available",
  priority: ["High"],
  prefersFoodType: [],
  rejectsFoodType: [],
  avoidsAllergens: [],
});

console.log("Search Results:", results);

// app.get('/search', async (req, res) => {
//     const results = await searchDonations({
//       ngoIri: req.query.ngoIri,
//       maxDistanceKm: parseFloat(req.query.maxDist) || 10,
//       status:    req.query.status?.split(','),
//       priority:  req.query.priority?.split(','),
//       donor:     req.query.donor?.split(','),
//       // …etc…
//     });
//     res.json(results);
//   });

// // 1. Insert new Donation in Mongo, get its _id
// const { insertedId } = await donations.insertOne({ …payload… });

// // 2. Push to GraphDB
// await sparqlClient.update(`
//   PREFIX : <http://…/FoodWastageOntology#>
//   INSERT DATA {
//     :donation_${insertedId} a :FoodDonation ;
//       :donationMongoID "${insertedId}" ;
//       :hasFoodType :Meat ;
//       … other props …
//   }
// `);

// // 3. Later, run your reasoning-driven search…
// const bindings = await sparqlClient.query( yourDynamicSearchQuery );
// // e.g. bindings = [ { mongoID: { value: "605c72f4a3" } }, … ]

// // 4. Bulk-fetch from Mongo by ID
// const ids = bindings.map(b => b.mongoID.value);
// const docs = await donations.find({ _id: { $in: ids.map(ObjectId) }}).toArray();
